Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Variance.

Inductive type4rec : typ -> Prop :=
  | type4_top :
      type4rec typ_top
  | type4_nat :
      type4rec typ_nat
  | type4_var : forall X,
      type4rec (typ_fvar X)
  | type4_arrow : forall T1 T2,
      type4rec T1 -> 
      type4rec T2 -> 
      type4rec (typ_arrow T1 T2)
  | type4_mu : forall L T,
      (forall X, X \notin L -> type4rec (open_tt T (typ_label X (open_tt T (typ_fvar X))))) ->
      (forall X, X \notin L -> type4rec (open_tt T (typ_fvar X))) ->
      type4rec (typ_mu T)
  | type4_all : forall L T1 T2,
      type4rec T1 ->
      (forall X, X `notin` L -> type4rec (open_tt T2 (typ_fvar X))) ->
      type4rec (typ_all T1 T2)
  | type4_label: forall l A,
      type4rec A ->
      type4rec (typ_label l A)
  | type4_single: forall l T,
      type4rec T ->
      type4rec (typ_single l T)
  | type4_and : forall T1 T2,
      type4rec T1 -> 
      type4rec T2 -> 
      type4rec (typ_and T1 T2)
  (* | type4_rcd_nil :
      type4rec typ_rcd_nil
  | type4_rcd_cons : forall i T1 T2,
      type4rec T1 ->
      type4rec T2 ->
      rt_type T2 ->
      type4rec (typ_rcd_cons i T1 T2) *)
.

Hint Constructors type4rec : core.

Lemma type4rec_to_type : forall A,
    type4rec A -> type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
  apply type_all with (L:=L)...
Qed.


Lemma subst_tt_type4rec : forall Z P T,
  type4rec T ->
  type4rec P ->
  type4rec (subst_tt Z P T).
Proof with auto using type4rec_to_type.
  intros Z P T HT HP.
  induction HT; simpl...
  -
    destruct (X == Z)...
  -
    apply type4_mu with (L:=L \u {{Z}});intros...
    specialize_x_and_L X L. specialize_x_and_L X L0.
    rewrite <- subst_tt_open_tt_twice...
    rewrite subst_tt_open_tt_var...
  -
    apply type4_all with (L:=L \u {{Z}});intros...
    rewrite subst_tt_open_tt_var...
  (* -
    apply type4_rcd_cons...
    apply Infrastructure.subst_tt_rt_type... *)
Qed.


Lemma type_to_rec : forall A,
    type A -> type4rec A.
Proof with auto.
  intros.
  induction H...
  -
    apply type4_mu with (L:=L \u fv_tt T)...
    intros.
    rewrite subst_tt_intro with (X:=X)...
    apply subst_tt_type4rec...
  -
    apply type4_all with (L:=L \u fv_tt T1 \u fv_tt T2)...
Qed.


Definition transitivity_on Q := forall E S T,
    sub E S Q -> sub E Q T -> sub E S T.

Lemma wf_env_narrowing: forall F Z Q E P,
    wf_env (F ++ Z ~ bind_sub Q ++ E) ->
    WF E P ->
    wf_env  (F ++ Z ~ bind_sub P ++ E).
Proof with auto.
  induction F;intros...
  -
    simpl...
    dependent destruction H...
    constructor...
  -
    dependent destruction H...
    +
      rewrite_env ((X, bind_sub T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
    +
      rewrite_env ((x, bind_typ T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
Qed.    

Lemma sub_narrowing_aux : forall Q F E Z P S T,
  transitivity_on Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  generalize dependent P.
  dependent induction H0;intros...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    destruct (X==Z);subst...
    +
      apply sa_trans_tvar with (U:=P)...
      apply H...
      * Case "P < Q".
        rewrite_env (nil ++ (F ++ Z ~ bind_sub P) ++ E).
        apply Sub_weakening...
        get_well_form...
        rewrite_env (F ++ Z ~ bind_sub P ++ E).
        apply wf_env_narrowing with (Q:=Q)...
      * Case "Q < T".
        analyze_binds_uniq H1...
        apply uniq_from_wf_env...
        get_well_form...
        dependent destruction BindsTacVal.
        apply IHsub with (Q0:=Q)...
    +
      apply sa_trans_tvar with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    constructor...
    apply IHsub1 with (Q0:=Q)...
    apply IHsub2 with (Q0:=Q)...
  -
    apply sa_all with (L:=L);intros...
    +
      apply IHsub1 with (Q0:=Q)...
    +
      apply IHsub2 with (Q0:=Q)...
    +
      rewrite_env ((X ~ bind_sub S2 ++ F) ++ Z ~ bind_sub P ++ E).
      apply H0 with (Q0:=Q)...
  -
    apply sa_rec with (L:=L \u fv_tt A1 \u fv_tt A2);intros...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      apply H3...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      apply H0...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply H2 with (Q0:=Q)...
  -
    constructor.
    apply IHsub with (Q0:=Q)...
  - apply sa_single. eapply IHsub. apply H. fsetdec. apply H1.
  - apply sa_and_a.
    -- eapply WF_narrowing. apply H1.
    -- eapply IHsub.
      --- apply H.
      --- fsetdec.
      --- apply H2.
  - apply sa_and_b. eapply WF_narrowing; eauto. eauto.
  - apply sa_and_both; eauto. 
    (* apply sa_rcd...
    + apply wf_env_narrowing with (Q:=Q)... get_well_form...
    + apply WF_narrowing with (V:=Q)...
    + apply WF_narrowing with (V:=Q)...
    + intros. apply H6 with (i:=i) (Q0:=Q)... *)
Qed.



Lemma WF_drop: forall A i E,
   
    WF E A -> WF E (dropLabel i A).
Proof with auto.
  intros.
  induction H;simpl;try solve [inversion H]...
  + apply WF_var with (U:=U)...
  + apply WF_all with (L:=L)...
    intros. unfold open_tt.
    rewrite open_tt_drop_var...
    add_nil.
    apply WF_narrowing with (V:=T1).
    apply H1...
  + apply WF_rec with (L:=L \u fv_tt A \u {{i}});intros.
    * unfold open_tt.
      rewrite open_tt_drop_var...
      apply H0...
    * rewrite subst_tt_intro with (X:=X)...
      ++ assert (WF (X ~ bind_sub typ_top ++ E) (open_tt (dropLabel i A) X)).
        { unfold open_tt.
          rewrite open_tt_drop_var...
          apply H0... }
        apply subst_tt_wf...
      ++ apply notin_drop_fv...
  + destruct (X==i)...
   (* destruct (i0==i)...
    constructor...
    * apply rt_type_drop with (E:=E)...
    * apply notin_drop_collect... *)
Qed.  


Lemma Tlookup_drop:forall i j T A,
    Tlookup j (dropLabel i A) = Some T ->
    Tlookup j A = Some T.
Proof with auto.
    apply Infrastructure.Tlookup_drop.
  (* intros.
  induction A;simpl in *;try solve [inversion H]...
  - destruct (a==i)... destruct (a==j)... subst. simpl in H. inversion H.
  - (* Tlookup j (dropLabel i (typ_and _ _)) = Some T -> Tlookup j (typ_and _ _) = Some T *)
    remember (Tlookup j (dropLabel i A1)) as TLA. destruct TLA.
    -- rewrite IHA1...
    -- destruct (i==j); subst; simpl...
      --- 
  apply label_belong in H.
  assert (j `notin` collectLabel (dropLabel j A)).
  apply notin_drop_self...
  assert (False).
  apply H0...
  destruct H1.
  simpl in H.
  destruct (a==j)... *)
Qed.

Lemma Tlookup_drop_flip: forall i A j t,
    Tlookup i A = Some t ->
    i <> j ->
    Tlookup i (dropLabel j A) = Some t.
Proof with auto.
  apply Infrastructure.Tlookup_drop_flip.
  (* intros.
  induction A;simpl in *;try solve [inversion H]...
  destruct (a==i)...
  destruct (a==j)...
  subst.
  destruct H0...
  simpl.
  destruct (a==i)...
  destruct n0...
  destruct (a==j)...
  simpl...
  destruct (a==i)...
  destruct n... *)
Qed.  


Lemma in_dec: forall T X,
    X \notin T \/ X \in T.
Proof with auto.
  intros.
  apply notin_diff_1.
  assert (AtomSetImpl.diff T T [=] Metatheory.empty).
  apply AtomSetProperties.diff_subset_equal.
  apply KeySetProperties.subset_refl.
  rewrite H...
Qed.


Lemma transitivity_on_and : forall T1 T2,
  transitivity_on T1 ->
  transitivity_on T2 ->
  transitivity_on (typ_and T1 T2).
Proof with auto.
  unfold transitivity_on.
  intros.
  dependent induction H2...
  - constructor... get_well_form...
  - clear IHsub. dependent induction H1...
    -- apply sa_trans_tvar with (U:=U)... apply IHsub with (T3:=T2) (T4:=T1)...
    -- apply sa_and_a... eapply IHsub with (T3:=T2) (T4:=T1)...
    -- apply sa_and_b... eapply IHsub with (T3:=T2) (T4:=T1)...
  - clear IHsub. dependent induction H1...
    -- apply sa_trans_tvar with (U:=U)... apply IHsub with (T3:=T2) (T4:=T1)...
    -- apply sa_and_a... eapply IHsub with (T3:=T2) (T4:=T1)...
    -- apply sa_and_b... eapply IHsub with (T3:=T2) (T4:=T1)...
  - apply sa_and_both.
    -- eapply IHsub1. apply H0. apply H. assumption. reflexivity.
    -- eapply IHsub2. apply H0. apply H. assumption. reflexivity.
Qed.


Lemma sub_transitivity : forall Q,
  transitivity_on Q.
Proof with auto.
  intros.
  unfold transitivity_on.
  intros.
  assert (type Q).
  get_type...
  apply type_to_rec in H1.
  generalize dependent S.
  generalize dependent T.
  generalize dependent E.
  induction H1;intros...
  - induction T; inversion H0... 

(*   
    dependent destruction H0...
    apply sa_and_both...
    -- 
      { inversion H0. }     *)
  - induction T; inversion H0...
    apply sa_top... apply sub_regular in H as [HX1 [HX2 HX3]]...
    (* dependent destruction H0...
    constructor...
    get_well_form...
    { inversion H0. } *)
  - 
    dependent induction H0...
    + constructor...
      get_well_form...
    + dependent induction H1...
      * apply sa_trans_tvar with (U:=U)...
      * apply sa_trans_tvar with (U:=U0)...
        apply IHsub0 with (X0:=X)...
      * apply sa_and_a. assumption. eapply IHsub0. apply H. assumption. assumption. reflexivity.
      * apply sa_and_b... eapply IHsub0... apply H.
    + apply sa_and_both...
      * eapply IHsub1...
      * eapply IHsub2...
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    + dependent induction H...
      * apply sa_trans_tvar with (U:=U)...
        apply IHsub with (T4:=T1) (T3:=T2)...
      * apply sa_and_a... eapply IHsub; eauto.
      * apply sa_and_b... eapply IHsub; eauto.
    + apply sa_and_both.
      * eapply IHsub1. apply H1_0. eauto. apply H1_. eauto. reflexivity. assumption.
      * eapply IHsub2. apply H1_0. eauto. apply H1_. eauto. reflexivity. assumption.
  -
    dependent induction H3...
    + constructor...
      get_well_form...
    + clear H6.
      dependent induction H7...
      * apply sa_trans_tvar with (U:=U)...
        apply IHsub with (T0:=T)...
      * clear H9.
        apply sa_rec with (L:=L \u L0 \u L1);intros...
        apply H0 with (X:=X)...
      * apply sa_and_a... eapply IHsub. apply H3. apply H4. apply H5. apply H. eauto. apply H1. apply H2. reflexivity.
      * apply sa_and_b... eapply IHsub. apply H3. apply H4. apply H5. apply H. eauto. apply H1. apply H2. reflexivity.
    + apply sa_and_both.
      -- eapply IHsub1...
      -- eapply IHsub2...
  -
    dependent induction H2...
    + constructor...
      get_well_form...
    + clear H2 IHsub1 IHsub2.
      dependent induction H4...
      * apply sa_trans_tvar with (U:=U)...
        apply IHsub with (T4:=T1) (T3:=T2)...
      * clear H2 IHsub1 IHsub2.
        apply sa_all with (L:=L \u L0 \u L1)...
        intros.
        apply H0 with (X:=X)...
        rewrite_env (nil ++ X ~ bind_sub S2 ++ E).
        apply sub_narrowing_aux with (Q:=T1)...
        unfold transitivity_on...
        apply H4...
      * apply sa_and_a... eapply IHsub; eauto.
      * apply sa_and_b... eapply IHsub; eauto.
    + apply sa_and_both.
      -- eapply IHsub1; eauto.
      -- eapply IHsub2; eauto.
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    + clear IHsub.
      dependent induction H...
      * apply sa_trans_tvar with (U:=U)...
        apply IHsub with (l0:=l) (A0:=A)...
      * apply sa_and_a... eapply IHsub; eauto.
      * apply sa_and_b... eapply IHsub; eauto.
    + apply sa_and_both.
      -- eapply IHsub1; eauto.
      -- eapply IHsub2; eauto.
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    + dependent induction H...
      * apply sa_trans_tvar with (U:=U)... eapply IHsub0; eauto.
      * apply sa_and_a... eapply IHsub0;eauto.
      * apply sa_and_b... eapply IHsub0;eauto.
    + apply sa_and_both.
      -- eapply IHsub1; eauto.
      -- eapply IHsub2; eauto.
  - apply transitivity_on_and with (T1:=T1) (T2:=T2);
    unfold transitivity_on...
Qed.

Lemma sub_narrowing : forall Q E F Z P S T,
  sub E P Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  apply sub_narrowing_aux with (Q:=Q)...
  apply sub_transitivity.
Qed.
